(import (r7rs)
        (srfi 151)
        (srfi 1)
        (chicken process-context))

(define (opcode s)
  (case s
    ((load)   #b00000)
    ((store)  #b01000)
    ((branch) #b11000)
    ((auipc)  #b00101)
    ((lui)    #b01101)
    ((op-imm) #b00100)
    ((op)     #b01100)
    ((jalr)   #b11001)
    ((jal)    #b11011)
    ((system) #b11100)))

(define shift arithmetic-shift)
(define b-and bitwise-and)
(define b-ior bitwise-ior)

(define (r-type opcode rd funct3 rs1 rs2 funct7)
  (b-ior
   (shift funct7 25)
   (shift rs2 20)
   (shift rs1 15)
   (shift funct3 12)
   (shift rd 7)
   (shift opcode 2)
   #b11))

(define (i-type opcode rd funct3 rs1 imm)
  (b-ior
   (shift imm 20)
   (shift rs1 15)
   (shift funct3 12)
   (shift rd 7)
   (shift opcode 2)
   #b11))

(define (s-type opcode funct3 rs1 rs2 imm)
  (b-ior
   (shift (shift imm -5) 25)
   (shift rs2 20)
   (shift rs1 15)
   (shift funct3 12)
   (shift (b-and imm #x1f) 7)
   (shift opcode 2)
   #b11))

(define (b-type opcode funct3 rs1 rs2 imm)
  (b-ior
   (shift (shift imm -12) 31)
   (shift (b-and (shift imm -5) 63) 25)
   (shift rs2 20)
   (shift rs1 15)
   (shift funct3 12)
   (shift (b-and (shift imm -1) 15) 8)
   (shift (b-and (shift imm -11) 1) 7)
   (shift opcode 2)
   #b11))

(define (u-type opcode rd imm)
  (b-ior
   (shift imm 12)
   (shift rd 7)
   (shift opcode 2)
   #b11))

(define (j-type opcode rd imm)
  (b-ior
   (shift (shift imm -19) 31)
   (shift (b-and (shift imm -0) 1023) 21)
   (shift (b-and (shift imm -10) 1) 20)
   (shift (b-and (shift imm -11) 255) 12)
   (shift rd 7)
   (shift opcode 2)
   #b11))

(define (branch->funct3 s)
  (case s
    ((beq) #b000)
    ((bne) #b001)
    ((blt) #b100)
    ((bge) #b101)
    ((bltu) #b110)
    ((bgeu) #b111)))

(define (load->funct3 s)
  (case s
    ((lb) #b000)
    ((lh) #b001)
    ((lw) #b010)
    ((lbu) #b100)
    ((lhu) #b101)))

(define (store->funct3 s)
  (case s
    ((sb) #b000)
    ((sh) #b001)
    ((sw) #b010)))

(define (op->funct3 s)
  (case s
    ((add sub addi) #b000)
    ((sll slli) #b001)
    ((slt slti) #b010)
    ((sltu sltiu) #b011)
    ((xor xori) #b100)
    ((srl sra srli srai) #b101)
    ((or ori) #b110)
    ((and andi) #b111)))

(define (op->funct7 s)
  (case s
    ((sub sra srai) #b0100000)
    (else #b0000000)))

(define (encode ins)
  (let ((mne (car ins)))
    (case mne
      ((lui)
       (let ((rd (cadr ins))
             (imm (caddr ins)))
         (u-type (opcode 'lui) rd imm)))
      ((auipc)
       (let ((rd (cadr ins))
             (imm (caddr ins)))
         (u-type (opcode 'auipc) rd imm)))
      ((jal)
       (let ((rd (cadr ins))
             (imm (caddr ins)))
         (j-type (opcode 'jal) rd imm)))
      ((jalr)
       (let ((rd (cadr ins))
             (rs1 (caddr ins))
             (imm (cadddr ins)))
         (i-type (opcode 'jalr) rd 0 rs1 imm)))
      ((beq bne blt bge bltu bgeu)
       (let ((rs1 (cadr ins))
             (rs2 (caddr ins))
             (imm (cadddr ins)))
         (b-type (opcode 'branch) (branch->funct3 mne) rs1 rs2 imm)))
      ((lb lh lw lbu lhu)
       (let ((rd (cadr ins))
             (rs1 (caddr ins))
             (imm (cadddr ins)))
         (i-type (opcode 'load) rd (load->funct3 mne) rs1 imm)))
      ((sb sh sw)
       (let ((rs1 (cadr ins))
             (rs2 (caddr ins))
             (imm (cadddr ins)))
         (s-type (opcode 'store) (store->funct3 mne) rs1 rs2 imm)))
      ((addi slti sltiu xori ori andi)
       (let ((rd (cadr ins))
             (rs1 (caddr ins))
             (imm (cadddr ins)))
         (i-type (opcode 'op-imm) rd (op->funct3 mne) rs1 imm)))
      ((slli srli srai)
       (let ((rd (cadr ins))
             (rs1 (caddr ins))
             (shamt (cadddr ins)))
         (r-type (opcode 'op-imm) rd (op->funct3 mne) rs1 shamt (op->funct7 mne))))
      ((add sub sll slt sltu xor srl sra or and)
       (let ((rd (cadr ins))
             (rs1 (caddr ins))
             (rs2 (cadddr ins)))
         (r-type (opcode 'op) rd (op->funct3 mne) rs1 rs2 (op->funct7 mne))))
      )))


(import (chicken syntax))

(define-syntax asm
  (ir-macro-transformer
   (lambda (exp inject compare)
     (letrec ((asm-quote
               (lambda (xs)
                 (map (lambda (i) (cond
                              ((symbol? i) `(quote ,i))
                              ((list? i) `(list ,@(asm-quote i)))
                              (else i)))
                      xs))))
       `(,(quote assemble)
         ,@(let ((clauses (cdr exp)))
             (asm-quote clauses)))))))

(define (resolve-ins-symbols ins pc syms)
  (map (lambda (x)
         (cond
          ((symbol? x) (let ((pair (assq x syms)))
                         (if pair
                           (let ((val (cdr pair)))
                             (cond
                              ((procedure? val) (val pc))
                              (else val)))
                           x)))
          (else x)))
       (cdr ins)))

(define +default-symbols+
  '((x0 . 0) (x1 . 1) (x2 . 2) (x3 . 3)
    (x4 . 4) (x5 . 5) (x6 . 6) (x7 . 7)
    (x8 . 8) (x9 . 9) (x10 . 10) (x11 . 11)
    (x12 . 12) (x13 . 13) (x14 . 14) (x15 . 15)
    (x16 . 16) (x17 . 17) (x18 . 18) (x19 . 19)
    (x20 . 20) (x21 . 21) (x22 . 22) (x23 . 23)
    (x24 . 24) (x25 . 25) (x26 . 26) (x27 . 27)
    (x28 . 28) (x29 . 29) (x30 . 30) (x31 . 31)))

(define (collect-labels program syms)
  (let loop ((program program)
             (pc 0)
             (syms syms))
    (if (null? program)
      syms
      (let ((ins (car program)))
        (cond
         ((symbol? ins)
          (loop (cdr program) pc (alist-cons ins (lambda (ipc) (- pc ipc)) syms)))
         ((list? ins)
          (loop (cdr program) (+ 4 pc) syms)))))))

(define (resolve-symbols program syms)
  (let loop ((program program)
             (pc 0))
    (if (null? program)
      '()
      (let ((ins (car program)))
        (cond
         ((list? ins)
          (cons (cons (car ins) (resolve-ins-symbols ins pc syms))
                (loop (cdr program) (+ 4 pc))))
         ((symbol? ins)
          (loop (cdr program) pc)))
        ))))

(define (num->bytevector n)
  (let ((v (make-bytevector 4)))
    (bytevector-u8-set! v 0 (bitwise-and (arithmetic-shift n -0) #xff))
    (bytevector-u8-set! v 1 (bitwise-and (arithmetic-shift n -8) #xff))
    (bytevector-u8-set! v 2 (bitwise-and (arithmetic-shift n -16) #xff))
    (bytevector-u8-set! v 3 (bitwise-and (arithmetic-shift n -24) #xff))
    v))

(define (encode-program program)
  (map (compose num->bytevector encode) program))

(define (assemble program port)
  (let* ((syms (collect-labels program +default-symbols+))
         (program1 (resolve-symbols program syms)))
    (for-each
     (lambda (ins-word) (write-bytevector ins-word port))
     (encode-program program1))))

(define (main)
  (let* ((args (command-line-arguments))
         (in-file (car args))
         (out-file (cadr args)))
    (let ((in (open-input-file in-file))
          (out (open-output-file out-file)))
      (assemble (read in) out))))

(main)
